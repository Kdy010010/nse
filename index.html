<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>블록 확장 및 기능 추가</title>
  <!-- Blockly CDN -->
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <!-- data.js 파일 불러오기 -->
  <script src="data.js"></script>
  <style>
    #stage {
      width: 500px;
      height: 400px;
      border: 2px solid black;
      position: relative;
      background-color: lightblue;
      margin-top: 20px;
    }

    .sprite {
      width: 50px;
      height: 50px;
      position: absolute;
      background-color: red;
      left: 0;
      top: 0;
    }

    .green-flag {
      width: 50px;
      height: 50px;
      background-color: green;
      display: inline-block;
      cursor: pointer;
      margin: 10px 0;
    }
  </style>
</head>
<body>

  <h1>블록 확장 및 기능 추가</h1>

  <!-- Blockly 작업 공간 -->
  <div id="blocklyDiv" style="height: 400px; width: 600px;"></div>

  <!-- 스프라이트가 있는 스테이지 -->
  <div id="stage">
    <div id="sprite1" class="sprite"></div>
  </div>

  <!-- 그린 플래그 (코드 실행 버튼) -->
  <div class="green-flag" onclick="runCode()"></div>

  <!-- 실행 버튼 -->
  <button onclick="runCode()">코드 실행</button>

  <!-- 내보내기 및 불러오기 버튼 -->
  <button onclick="exportBlocks()">블록 내보내기</button>
  <button onclick="importBlocks()">블록 불러오기</button>

  <script>
    // 스프라이트 선택 및 제어
    const sprite = document.getElementById('sprite1');
    let isCircle = false; // 모양 상태를 저장

    function moveSpriteX(distance) {
      let currentLeft = window.getComputedStyle(sprite).left;
      currentLeft = parseInt(currentLeft === 'auto' ? 0 : currentLeft, 10) || 0;
      sprite.style.left = (currentLeft + distance) + 'px';
    }

    function moveSpriteY(distance) {
      let currentTop = window.getComputedStyle(sprite).top;
      currentTop = parseInt(currentTop === 'auto' ? 0 : currentTop, 10) || 0;
      sprite.style.top = (currentTop + distance) + 'px';
    }

    function changeSpriteShape() {
      if (isCircle) {
        sprite.style.borderRadius = '0%'; // 사각형
        sprite.style.backgroundColor = 'red';
      } else {
        sprite.style.borderRadius = '50%'; // 원형
        sprite.style.backgroundColor = 'blue';
      }
      isCircle = !isCircle; // 모양 토글
    }

    // data.js에서 불러온 data 사용
    const actions = data.actions;

    // 블록 정의 및 코드 생성기 설정
    for (let actionName in actions) {
      const action = actions[actionName];

      // 블록 정의
      Blockly.Blocks[actionName] = {
        init: function() {
          this.appendDummyInput()
              .appendField(action.block.message);
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(action.block.colour);
        }
      };

      // 코드 생성기 정의
      Blockly.JavaScript[actionName] = function(block) {
        return action.code + '\n';
      };
    }

    // 툴박스 XML 생성
    let toolboxXml = '<xml xmlns="https://developers.google.com/blockly/xml">';
    for (let actionName in actions) {
      toolboxXml += `<block type="${actionName}"></block>`;
    }
    toolboxXml += '</xml>';

    // Blockly 작업 공간 초기화
    const workspace = Blockly.inject('blocklyDiv', {
      toolbox: toolboxXml
    });

    // Blockly로 생성된 코드를 실행하는 함수
    function runCode() {
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      try {
        eval(code); // Blockly가 생성한 코드를 실행
      } catch (e) {
        console.error(e);
        alert('코드 실행 중 오류가 발생했습니다.');
      }
    }

    // 블록 내보내기 기능 (저장)
    function exportBlocks() {
      var xml = Blockly.Xml.workspaceToDom(workspace);
      var xml_text = Blockly.Xml.domToText(xml);
      localStorage.setItem('blocklyXml', xml_text); // 로컬스토리지에 저장
      alert("블록이 저장되었습니다!");
    }

    // 블록 불러오기 기능 (로드)
    function importBlocks() {
      var xml_text = localStorage.getItem('blocklyXml');
      if (xml_text) {
        var xml = Blockly.Xml.textToDom(xml_text);
        Blockly.Xml.clearWorkspaceAndLoadFromXml(xml, workspace);
        alert("블록이 불러와졌습니다!");
      } else {
        alert("저장된 블록이 없습니다.");
      }
    }
  </script>

</body>
</html>
